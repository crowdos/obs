#!/usr/bin/python
# -*- coding: utf-8 -*-

import argparse
import os
import sys
import logging
import subprocess
import time
import socket
import pwd
import urlparse
import shutil

# This is stolen from tar_scm OBS service
def run_cmd(cmd, cwd, raisesysexit=False, extra_env={}):
    """Execute the command cmd in the working directory cwd and check return
    value. If the command returns non-zero and raisesysexit is True raise a
    SystemExit exception otherwise return a tuple of return code and command
    output.
    """
    logging.debug("COMMAND: %s", cmd)

    # Ensure we get predictable results when parsing the output of commands
    # like 'git branch'
    env = os.environ.copy()
    env['LANG'] = 'C'

    for key in extra_env:
        env[key] = extra_env[key]

    proc = subprocess.Popen(cmd,
                            shell=False,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.STDOUT,
                            cwd=cwd,
                            env=env)

    output = proc.communicate()[0]

    if proc.returncode and raisesysexit:
        logging.info("ERROR(%d): %s", proc.returncode, repr(output))
        sys.exit("Command failed(%d): %s" % (proc.returncode, repr(output)))
    else:
        logging.debug("RESULT(%d): %s", proc.returncode, repr(output))
    return (proc.returncode, output)

class GitRepo:
    def __init__(self, args, conf):
        self.args = args
        self.conf = conf
        self.clone_dir = None
        self.version = None
        self.cache = False

    def init(self):
        self.__get_clone_dir()
#        if self.cache and not os.path.exists(self.cache_dir):
#            os.makedirs(self.cache_dir)

        if not os.path.exists(self.clone_dir):
            os.makedirs(self.clone_dir)

    def clone(self):
        if self.cache:
            if os.path.exists(self.cache_dir):
                run_cmd(['git', 'fetch', '-q', '--prune', '--all', '--force'],
                        self.cache_dir, True)
            else:
                run_cmd(['git', 'clone', '-q', '--mirror', self.args.url, self.cache_dir],
                        self.args.outdir, True)
            run_cmd(['git', 'clone', '-q', self.cache_dir, self.clone_dir], self.args.outdir, True)
        else:
            run_cmd(['git', 'clone', '-q', self.args.url, self.clone_dir], self.args.outdir, True)

    def parse_url(self, url):
        if url.startswith('http://') or url.startswith('https://'):
            return self.__parse_http_url(url)
        elif 'github.com' in url:
            return self.__parse_github_url(url)
        else:
            sys.exit('Cannot parse URL %s' % url)

    def __get_clone_dir(self):
        url = self.args.url
        host, path = self.parse_url(url)
        logging.debug('parsed url %s to %s %s' % (url, host, path))

        cache_dir = self.conf['cache_dir']
        if cache_dir:
            self.cache = True
            self.cache_dir = os.path.join(cache_dir, host, path)

        self.clone_dir = os.path.join(self.args.outdir, 'git')

    def checkout_branch(self):
        run_cmd(['git', 'checkout', self.args.branch], self.clone_dir, True)

    def reset_revision(self):
        run_cmd(['git', 'reset', '--hard', self.args.revision], self.clone_dir, True)

    def set_version(self):
        # Get the last version:
        cl=os.path.join(self.clone_dir, "debian/changelog")
        ret, ver = run_cmd(["dpkg-parsechangelog", '-l', cl, '-S', 'Version'],
                           self.clone_dir, True)
        ver=ver.rstrip()

        if ver == self.args.revision:
            # We are happy
            self.version = ver
            return

        # revision can be either a tag or a sha or HEAD
        # If it's a tag then it has to have a corresponding debian/changelog entry
        if self.revision_is_tag():
            sys.exit("revision %s does not have a corresponding debian/changelog entry"
                     % self.args.revision)

        sha = self.args.revision
        if sha == 'HEAD':
            ret, out = run_cmd(['git', 'show'], self.clone_dir, True)
            out = out.split('\n')[0].split(" ")
            if out[0] != 'commit':
                sys.exit('malformed output %s' % " ".join(out))
            sha = out[1]

        self.version='+'.join([ver, "%s" % int(time.time()), "git.%s" % sha[:7]])

        # This is ugly but we don't want to change a package between native and non-native
        if '-' in ver:
            self.version += '-1'

        text="Automatic entry by git_dsc service"
        self.__run_dch(['-v', self.version, text], self.clone_dir)
        self.__run_dch(['-r', text], self.clone_dir)

    def revision_is_tag(self):
        ret, out = run_cmd(['git', 'describe', '--tags', '--exact-match'], self.clone_dir, False)
        return ret == 0

    def cleanup(self):
        shutil.rmtree(self.clone_dir)

    def __run_dch(self, cmd, cwd):
        env = {'DEBFULLNAME': self.conf['deb_name'],
               'DEBEMAIL': self.conf['deb_email']}
        command = ['dch', '--noconf']
        command.extend(cmd)
        return run_cmd(command, cwd, True, env)

    def __parse_http_url(self, url):
        parts = urlparse.urlparse(url)

        host = parts[1]
        path = parts[2]
        if path.endswith('.git'):
            path = path[:-4]

        return (host, path)

    def __parse_github_url(self, url):
        # git@github.com:owner/repos.git
        path = url.split(':')[1]

        if path.endswith('.git'):
            path = path[:-4]

        return ('git@github.com', path)

class Config:
    def __init__(self):
        self.conf = {'cache_dir': None,
                     'deb_name': 'Git DSC service',
                     'deb_email':'%s@%s' % (pwd.getpwuid(os.getuid()).pw_name, socket.getfqdn())}

    def read(self, file):
        for line in file:
            line = line.rstrip().lstrip()
            if line.startswith('#'):
                continue
            key, val = line.split('=')
            key = key.rstrip()
            val = val.lstrip()
            if len(key) == 0:
                continue

            if len(val) == 0:
                logging.debug("Removing configuration key %s" % key)
                del self.conf[key]
                continue

            self.conf[key] = val
            logging.debug("Setting configuration %s=%s" % (key, val))

def parse_args():
    parser = argparse.ArgumentParser(description='Git to DSC')
    parser.add_argument('-v', '--verbose',
                        action='store_true', default=False, help='Enable verbose output')
    parser.add_argument('-u', '--url', required=True,
                        help='URL of git repo to clone')
    parser.add_argument('-o', '--outdir', required=True,
                        help='OBS service parameter. Path to output directory')
    parser.add_argument('-b', '--branch', help='name of branch to use. Defaults to master')
    parser.add_argument('-r', '--revision', help='commit SHA1 or tag to use. Defaults to HEAD')
    args = parser.parse_args()

    if not args.branch:
        args.branch = "master"

    if not args.revision:
        args.revision = "HEAD"

    if not os.path.isdir(args.outdir):
        sys.exit("%s: No such directory" % args.outdir)

    if os.getenv('DEBUG_GIT_DSC'):
        args.verbose = True

    return args

def read_conf():
    conf = Config()
    for name in ['/etc/obs/services/git_dsc', os.path.expanduser('~/.obs/git_dsc')]:
        if os.path.isfile(name):
            logging.debug("Reading configuration file %s" % name)
            conf.read(open(name))

    if not conf.conf['deb_name']:
        sys.exit('deb_name is not configured')

    if not conf.conf['deb_email']:
        sys.exit('deb_email is not configured')

    if conf.conf['cache_dir'] and not os.path.isdir(conf.conf['cache_dir']):
        sys.exit('cache dir %s does not exist' % conf.conf['cache_dir'])

    return conf.conf

def main():
    args = parse_args()
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    conf = read_conf()

    git=GitRepo(args, conf)
    git.init()
    git.clone()
    git.checkout_branch()
    git.reset_revision()
# TODO: submodules
    git.set_version()
    logging.debug("Version will be %s" % git.version)

    ret, out = run_cmd(['dpkg-source', '-b', git.clone_dir],
                       args.outdir, True)

    git.cleanup()

    for i in out.split("\n"):
        if i.endswith(".dsc"):
            name=os.path.join(args.outdir, i.split(" ")[-1])
            logging.debug("DSC file is %s" % name)
            f=open(name, 'a')
            f.write("OBS-DCH-RELEASE: 1")
            return

    sys.exit("Cannot find generated dsc file")

if __name__ == '__main__':
    main()
